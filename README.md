# NITree

This is a proof of concept implementation for an algorithm that uses Named Identifiers (see [RFC 6920](https://www.rfc-editor.org/info/rfc6920) ) to hash a given key-value data structure (e.g. JSON) into a merkle tree like structure can be shared wihtout loosing full fine grained data access control. Publishing this Named Identifiers Tree (root), e.g. on a distributed ledger, can be used to notarize the full data structure. Furthermore, RFC 6920 specifies a URL too query for the data behind the NI. The data owner being querried can then authorise the querying party and reveal parts or all of the data in the NITree. By checking the hashes, the querying party can be sure to receive authentic data.


## Specs

### Input

For simplicity, we consider only the following data types:
- A String is an Object
- An unordered List of Objects is an Object
- An unordered Map of Strings to Objects is an Object
- The empty String/List/Map are all considered to be the same (emty) Object `""`

The Input to the NITree generating Algorithm may be any Object.

### Root

A root of an NITree is a named identifier of the form "ni://n-authority/alg;val" where
- "alg" is the name of a hashing algorithm, e.g. "sha-256", see [RFC 6920](https://www.rfc-editor.org/info/rfc6920) for details. We will throughout use sha-256 for the specification, but of course any other cryptographic hash algorithm may be used in practise.
- "n-authority" is a domain name, e.g. "example.com". n-authority SHOULD be given for the main root in order to allow for data lookup. It MAY be omitted for sub-tree roots, in which case it is assumed to be the same as for the main root.
- "val" is the hash value

### Collisions

Different data inputs are to yield different main roots (up to collisions in the underlying hashing alg).

### Algorithm

#### Salted NIs for Strings

A string is converted into a root by first applying alg to the to generate a named identifier of the form
`ni://alg;val`. E.g. "Hello World!" yields `ni://sha-256;03ba204e50d126e4674c005e04d82e84c21366780af1f43bd54a37816b6ab340`.

To prevent rainbow ttable/guessing attacks on the hash, the result SHOULD be salted and hashed again as follows:
A random salt is appended as a query parameter according to RFC 6920, e.g.
`ni://sha-256;03ba204e50d126e4674c005e04d82e84c21366780af1f43bd54a37816b6ab340?salt=NIPSI2XQLTRCNIUAYBNNWV6K5Q`. The length (entropy) of the salt can be adapted according to security needs. The resulting NI + salt is considered a string and hashed again into a new NI, e.g.
`ni://example.com/sha-256;319415cf8baadb98f52b775d496c391c4c02ba881e7e739a27f9afc15ac3b2f9`

If the original String already contains enough entropy, e.g. a large random number such as a serial, the salting step MAY be omitted.

The Empty String should always be salted.

The resulting NI is the NIRoot as well as the NITree of the string object.


#### NIs for Lists

An unordered list of objects is mapped to a NIRoot by first converting all elements to NIs. The n-authority parts for the elements SHOULD be omitted. If an n-authority is given for one element, it MUST be given for all elements. This list of NIs is the NITree of the list. The NI of the list is then generated by lexicographic sorting of the element NIs, concatenating them as strings and hashing the resulting string.

For Example `["Hello", "World"]` yields the NITree
`["ni://sha-256;6a045b452102c59d840ec097d59d9467e13a3f34f6494e539ffd32c1bb35f18", "ni://sha-256;a1db5c660d3d1f3f4f9361b9848694300929be94b74c84452a87420c59e5df9"]`
where salting has been omitted for simplicity in this example, but should be used for such simple values in practise. The root of this tree is
`ni://sha-256;3a8598032bf724139ad47f0ed685cd9e3004e0bd5ddc841e60521ee214e96a8d`.


#### NIs for Maps

The interesting part of the algorithm is hashing key-value pairs, i.e. maps.

The NITree of the map is generated by replacing all values for all keys in the map by their corresponding NITrees.
To generate the NIroot, the map is converted to a list of string objects by concatenating each key with the NIRoot of its value. The NIRoot of the resulting list of strings is the NIRoot of the map.

For example (again omitting hashing), the map
`{"A" : "Hello", "B" : "World"}`
has the NITree
`{"A" : "ni://sha-256;6a045b452102c59d840ec097d59d9467e13a3f34f6494e539ffd32c1bb35f18", "B" : "ni://sha-256;a1db5c660d3d1f3f4f9361b9848694300929be94b74c84452a87420c59e5df9"}`
and NIRoot
`ni://example.com/sha-256;377a9ef525b4913c5ea8509fae1b076a8e57a4164b228d44d3b0f5fe7204e747`



## License

Copyright 2020 Sebastian Schmittner <sebastian@schmittner.pw>

<img alt="GPLV3" style="border-width:0" src="http://www.gnu.org/graphics/gplv3-127x51.png" /><br />

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
